モデル検査初級編<br>
例題「システムアルファα」

# 1. モデルについて

## 1-1. モデル概要

* システムαは２つの変数aとb、および１つのスイッチからなる
* 変数aとbは、[0,1,2]のいずれかの値をとる
* スイッチは[on, off]のいずれかの状態をとる
* 変数aとbは互いに連携しながら変化する
* スイッチは変数aとbの値によって決まる

## 1-2. 動作仕様

- 各変数は同期して変化
- 変数aについて
  - 初期状態は0とする
  - 0->1, 1->2, 2->0と繰り返し変化する
  - ただし、b = 1の時は変化しない
- 変数bについて
  - 初期状態は0とする
  - 0->1, 1->2, 2->0と繰り返し変化する
  - ただし、a = bの時は変化しない
- スイッチについて
  - 初期状態はoff
  - a = b = 2ならonになる
  - a = b = 1ならoffになる
  - それ以外は変化しない

## 1-3. 検査項目

 1. スイッチがoffならば、いずれonになる
 2. スイッチがonならば、いずれoffになる

## 1-4. Promela記述

1-1, 1-2の内容をPromeka記述にしたものを、systemAlpha.pmlに示す。

スイッチを表す変数は、変数名をそのまま`switch`とするとC構文switchと判別されてコンパイル時にエラーとなるため、変数`sw`とする。

# 2. Spinでの動作確認

## 2-1. シミュレーションの実行

無限実行されるモデルなので、深さ制限シミュレーションで実行する。

```
spin -u1000 systemAlpha.pml
```
## 2-2. 検査 (Verification)

### 2-2-1. LTL式の作成

`pが真ならば、いつかqが真になる`がいつでも成り立つ、という形で表現する。これを式に書くと

```
G(p -> Fq)
```
となる。Spinでの記述は以下のようになる。
```
[](p-> <>q)
```
これをSpinで検査式を生成する。

```
spin -f "[](p -> <>q)" > v1.ltl
```

`v1.ltl`に以下のpとqの定義を追加する。

1. スイッチがoffならば、いずれonになる


```
// v1.ltl
// 以下の２行を追加する。
#define p (sw == off)
#define q (sw == on)

never  {    /* [](p -> <>q) */
T0_init:
	do
	:: (((! ((p))) || ((q)))) -> goto accept_S20
	:: (1) -> goto T0_S27
	od;
accept_S20:
	do
	:: (((! ((p))) || ((q)))) -> goto T0_init
	:: (1) -> goto T0_S27
	od;
accept_S27:
	do
	:: ((q)) -> goto T0_init
	:: (1) -> goto T0_S27
	od;
T0_S27:
	do
	:: ((q)) -> goto accept_S20
	:: (1) -> goto T0_S27
	:: ((q)) -> goto accept_S27
	od;
}
```

### 2-2-2. 検査器の作成

以下のコマンドを実行する。

```
spin -a -N v1.ltl systemAlpha.pml
gcc pan.c -o systemAlpha_v1
./alphaSystem_v1
```
